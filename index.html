<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
 <head> 
    <script>


</script>
  <head> 
 
<link rel="stylesheet" href="main.css">  </head>
<style>
.select-style {
    border: 1px solid #ccc;
    width: 120px;
    border-radius: 3px;
    overflow: hidden;
    background: #a6bddb ;
}

.select-style select {
    padding: 5px 8px;
    width: 130%;
    border: none;
    font-size: 1em;
    box-shadow: none;
    text-align-last: center;
    padding-right: 40px;
    background: transparent;
    background-image: none;
    -webkit-appearance: none;
}

.select-style select:focus {
    outline: none;
}
#circle circle {
  fill: none;
  pointer-events: all;
}

.group path {
  /*fill-opacity: .5;*/
}

path.chord {
  stroke: #000;
  stroke-width: .25px;
}

#circle:hover path.fade {
  display: none;
}

     #tooltip {
        color: white;
        opacity: .9;
        background: #333;
        padding: 5px;
        border: 1px solid lightgrey;
        border-radius: 5px;
        position: absolute;
        z-index: 10;
        visibility: hidden;
        pointer-events: none;
      }
     .least {
        stroke: #fff5f0;
        fill: #fff5f0;
     }

     .most {
        stroke: #67000d;
        fill: #67000d;
     }
     .lowest {
        stroke: #fff7fb;
        fill: #fff7fb;
     }

     .highest {
        stroke: #023858;
        fill: #023858;
     }
</style>

<body>
    <div id="tooltip"></div>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/1.13.0/d3-legend.js"></script>
<script src="underscore.js"></script>


<h1>NHL Buddy-Buddy Chart</h1>
<h2>Analytics even Bruins fans can understand</h2>
<p>How to read this chart<p>
<p>1. Chords show the goal production between players. Thicker the better the offensive chemistry. <br /> 
2. Reds represent a player's total points. The darker the better.  <br /> 
3. Blues highlight which players connect for the most goals. The darker the more offensively productive.<br /> 4. Arc length shows the number of goals by a player. The longer, the more goals. <p>
<!-- <p>This chart displays the goal production between two players. A thicker line indicates more goals.<b> 2017-2018 regular season. Updates daily.</b></p> -->
<div class="select-style">

<select class="teams">
  <option  value="Anaheim">Anaheim</option>
  <option  value="Arizona">Arizona</option>
  <option  value="Buffalo">Buffalo</option>
  <option  value="Boston">Boston</option>
  <option  value="Calgary">Calgary</option>
  <option  value="Carolina">Carolina</option>
  <option  value="Chicago">Chicago</option>
  <option  value="Colorado">Colorado</option>
  <option  value="Columbus">Columbus</option>
  <option  value="Dallas">Dallas</option>
  <option  value="Detroit">Detroit</option>
  <option  value="Edmonton">Edmonton</option>
  <option  value="Florida">Florida</option>
  <option  value="Los Angeles">Los Angeles</option>
  <option  value="Minnesota">Minnesota</option>
  <option  value="Montreal"  selected="selected">Montreal</option>
  <option  value="Nashville">Nashville</option>
  <option  value="New Jersey">New Jersey</option>
  <option  value="NY Rangers">NY Rangers</option>
  <option  value="NY Islanders">NY Islanders</option>
  <option  value="Ottawa">Ottawa</option>
  <option  value="Philadelphia">Philadelphia</option>
  <option  value="Pittsburgh">Pittsburgh</option>
  <option  value="San Jose">San Jose</option>
  <option  value="St. Louis">St. Louis</option>
  <option  value="Tampa Bay" >Tampa Bay</option>
  <option  value="Toronto">Toronto</option>
  <option  value="Vancouver">Vancouver</option>
  <option  value="Vegas">Vegas</option>

  <option  value="Washington">Washington</option>
  <option  value="Winnipeg">Winnipeg</option>
  
</select>
</div>
<div>
<div id="chart_placeholder"></div>
<svg></svg>
<script>
/*** Define parameters and tools ***/
var width = 960,
    height = 800,
    outerRadius = Math.min(width, height) / 2 - 100,
    innerRadius = outerRadius - 18;
var test
var year = 2018

var dataset = "Montreal_matrix" + year + ".json";
//string url for the initial data set
//would usually be a file path url, here it is the id
//selector for the <pre> element storing the data

//create number formatting functions
var formatPercent = d3.format("%");
var numberWithCommas = d3.format("0,f");

//create the arc path data generator for the groups
var arc = d3.svg.arc()
    .innerRadius(innerRadius)
    .outerRadius(outerRadius);

//create the chord path data generator for the chords
var path = d3.svg.chord()
    .radius(innerRadius);


var color = d3.scale.quantize()
    // .domain([1,12])
    .range(['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'])


var color1 = d3.scale.quantize()
    // .domain([1,12])
    .range(['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'])



//define the default chord layout parameters
//within a function that returns a new layout object;
//that way, you can create multiple chord layouts
//that are the same except for the data.
function getDefaultLayout() {
    return d3.layout.chord()
        .padding(0.03)
        .sortGroups(d3.descending)
        .sortChords(d3.ascending);
}
var last_layout; //store layout between updates
var players; //store neighbourhood data outside data-reading function
var assists; //
/*** Initialize the visualization ***/
var g = d3.select("#chart_placeholder").append("svg")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("id", "circle")
    .attr("transform",
        "translate(" + width / 2 + "," + height / 2 + ")");
//the entire graphic will be drawn within this <g> element,
//so all coordinates will be relative to the center of the circle

g.append("circle")
    .attr("r", outerRadius);
//this circle is set in CSS to be transparent but to respond to mouse events
//It will ensure that the <g> responds to all mouse events within
//the area, even after chords are faded out.

/*** Read in the neighbourhoods data and update with initial data matrix ***/
//normally this would be done with file-reading functions
//d3.csv and d3.json and callbacks, 
//instead we're using the string-parsing functions
//d3.csv.parse and JSON.parse, both of which return the data,
//no callbacks required.
// var svg = d3.select("svg")
// var quantize = d3.scale.quantize()
//   // .domain([0,28])
//   .range(['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d']);

var svg = d3.select("svg");

// svg.append("g")
//   .attr("class", "legendLinear")
//   // .attr("transform", "translate(20,20)");

// var legendquantize = d3.legend.color()
//   .shapeWidth(10)
//   .labels(["least", " ", " ", " "," ", " ", " ", " ", "most"])
//   .orient('horizontal')
//   .title("Player points")
//   .scale(quantize);

// svg.select(".legendLinear")
// .attr('transform', 'translate(660,20)')
//   .call(legendquantize);
          
        //create legend
        // var legendScale = d3.scale.ordinal()
        //     .domain(['Least', 'Most'])
        //     .range(['least', 'most'])

        // //d3-legend
        // var legend = d3.legend.color()
        //     .shapePadding(5)
        //     .useClass(true)
        //     .title("Player points")
        //     .scale(legendScale);

        // svg.append('g')
        //     .attr('transform', 'translate(680,0)')
        //     .call(legend);

        // //create legend
        // var legendScale1 = d3.scale.ordinal()
        //     .domain(['Lowest', 'Highest'])
        //     .range(['lowest', 'highest'])

        // //d3-legend
        // var legend1 = d3.legend.color()
        //     .shapePadding(5)
        //     .useClass(true)
        //     .title("Chemistry")
        //     .scale(legendScale1);

        // svg.append('g')
        //     .attr('transform', 'translate(680,80)')
        //     .call(legend1);


d3.csv("Montreal_players" + year + ".csv", function(error, playerData) {
    if (error) {
        alert("Error reading file: ", error.statusText);
        return;
    }

    // d3.csv("assistData.csv", function(error, assistsData){
    //     // console.log(assistsData)
    //     assists = assistsData;

    // })


    players = playerData;
    mmap = players;
    //store in variable accessible by other functions


    updateChords(dataset);
    // call the update method with the default dataset

}); //end of d3.csv function


/* Create OR update a chord layout from a data matrix */
function updateChords(datasetURL) {

    d3.json(datasetURL, function(error, matrix) {
        // console.log(matrix)
        if (error) {
            alert("Error reading file: ", error.statusText);
            return;
        }


        // var matrix = JSON.parse( d3.select(datasetURL).text() );
        // instead of d3.json

        /* Compute chord layout. */
        layout = getDefaultLayout(); //create a new layout object
        layout.matrix(matrix);
        // console.log(layout.groups())

        /* Create/update "group" elements */
        var groupG = g.selectAll("g.group")
            .data(layout.groups(), function(d) {
                // console.log(d)
                return d.index;
                //use a key function in case the 
                //groups are sorted differently between updates
            });

        console.log(groupG[0])

        groupG.exit()
            .transition()
            .duration(1500)
            .attr("opacity", 0)
            .remove(); //remove after transitions are complete


        var newGroups = groupG.enter().append("g")
            .attr("class", "group");
            // console.log(newGroups)
        //the enter selection is stored in a variable so we can
        //enter the <path>, <text>, and <title> elements as well


        //create the arc paths and set the constant attributes
        //(those based on the group index, not on the value)
    
        test = newGroups

        // console.log(d3.max(newGroups[0],function(d){
        //     return d['__data__'].value
        // }))
        // console.log(players)
        // console.log(d3.max(players, function(d) {
        //     return +d.points
        // }))
        color1.domain([1, d3.max(players, function(d) {
            return +d.points
        })])


        newGroups.append("path")
        //     .attr('class','ends')
            .attr("id", function(d) {
                return "group" + d.index;
                //using d.index and not i to maintain consistency
                //even if groups are sorted
            })
        //     .style("fill", function(d, i) {
        //         // console.log(d)
        //         //this is the outter circle bar. Could represent goals
        //         // console.log(color1(d.value))
        //         return color1(d.value)
        //     });
    



        // newGroups
        //     .attr("id", function(d) {
        //         return "group" + d.index;
        //         //using d.index and not i to maintain consistency
        //         //even if groups are sorted
        //     })
            // .style("fill", function(d, i) {
            //     // console.log(d)
            //     //this is the outter circle bar. Could represent goals
            //     // console.log(color1(d.value))
            //     return color1(d.value)
            // });

                //update the paths to match the layout
        groupG.select("path")
            .transition()
            .duration(100)
            // .attr("opacity", 0.5) //optional, just to observe the transition
            .attrTween("d", arcTween(last_layout))
            .transition().duration(100).attr("opacity", 1)
            .style("fill", function(d, i) {
                // console.log(players)
                // console.log(i)
                //this is the outter circle bar. Could represent goals
                // console.log(color1(d.value))
                return color1(+players[i].points)
            })
             //reset opacity
        ;

        //create the group labels
        groupG.select("text").text(function(d) {
            return players[d.index].name;
        });
        // console.log(newGroups)

        newGroups.append("svg:text")
            .transition()
            .attr("xlink:href", function(d) {
                return "#group" + d.index;
            })
            .attr("dy", ".35em")
            .attr("color", "#fff")
            .attr("class", 'players')
            .text(function(d) {
                return players[d.index].name;
            });



        //position group labels to match layout
        groupG.select("text")
            .transition()
            .duration(1500)
            .attr("transform", function(d) {
                d.angle = (d.startAngle + d.endAngle) / 2;
                //store the midpoint angle in the data object

                return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")" +
                    " translate(" + (innerRadius + 26) + ")" +
                    (d.angle > Math.PI ? " rotate(180)" : " rotate(0)");
                //include the rotate zero so that transforms can be interpolated
            })
            .attr("text-anchor", function(d) {
                return d.angle > Math.PI ? "end" : "begin";
            });


        /* Create/update the chord paths */
        var chordPaths = g.selectAll("path.chord")
            .data(layout.chords(), chordKey);
        // test =chordPaths    


        //specify a key function to match chords
        //between updates


        //create the new chord paths
        var newChords = chordPaths.enter()
            .append("path")
            .attr("class", "chord");

        //*******************************************************************
        //  CHORD READER
        //*******************************************************************
        function chordRdr(matrix, mmap) {
            return function(d) {
                // console.log(d)
                var i, j, s, t, g, m = {};
                if (d.source) {
                    i = d.source.index;
                    j = d.target.index;
                    // console.log(i,j)
                    // console.log(_.where(mmap, {key: i }))
                    t = mmap[i]
                    s = mmap[j]
                    // console.log(s.name, t)
                    m.sname = s.name;
                    m.sdata = d.source.value;
                    m.svalue = +d.source.value;
                    m.stotal = _.reduce(matrix[i], function(k, n) {
                        return k + n
                    }, 0);
                    m.tname = t.name;
                    m.tdata = d.target.value;
                    m.tvalue = +d.target.value;
                    m.ttotal = _.reduce(matrix[j], function(k, n) {
                        return k + n
                    }, 0);
                } else {
                    g = _.where(mmap, {
                        id: d.index
                    });
                    m.gname = g[0].name;
                    m.gdata = g[0].data;
                    m.gvalue = d.value;
                }
                m.mtotal = _.reduce(matrix, function(m1, n1) {
                    return m1 + _.reduce(n1, function(m2, n2) {
                        return m2 + n2
                    }, 0);
                }, 0);
                return m;
            }
        }

        // // Update all group title texts
        // groupG.select("text")

        // Add title tooltip for each new chord.
        chordPaths.on("mouseover", function(d) {
                d3.select("#tooltip")
                    .style("visibility", "visible")
                    .html(chordTip(rdr(d)))
                    .style("top", function() {
                        return (d3.event.pageY - 130) + "px"
                    })
                    .style("left", function() {
                        return (d3.event.pageX - 100) + "px";
                    })
            })
            .on("mouseout", function(d) {
                d3.select("#tooltip").style("visibility", "hidden")
            });

        function chordTip(d) {
            // console.log(d)
            var p = d3.format(".1%"),
                q = d3.format(",f")
            return d.sname + q(d.svalue) + " assists on " + d.tname + " goals" +
                "<br/>"
                // + p(d.svalue/d.ttotal) + " of " + d.tname + "'s Total (" + q(d.ttotal) + ")<br/>"
                // + p(d.svalue/(d.mtotal/2)) + " of Matrix Total (" + q(d.mtotal/2) + ")<br/>"
                +
                "<br/>" +
                d.tname + q(d.tvalue) + " assists on " + d.sname + " goals" +
                "<br/>"
            // + p(d.tvalue/d.ttotal) + " of " + d.tname + "'s Total (" + q(d.ttotal) + ")<br/>"
            // + p(d.tvalue/(d.mtotal/2)) + " of Matrix Total (" + q(d.mtotal/2) + ")";
        }

        // console.log(dataset)
        var rdr = chordRdr(dataset, players);
        // console.log(d3.max(chordPaths[0],function(d){

        //         return (d['__data__'].source.value+d['__data__'].target.value)
        //     })
        //     )
        color.domain([1, d3.max(chordPaths[0], function(d) {
            return (d['__data__'].source.value + d['__data__'].target.value)
        })])

        //handle exiting paths:
        chordPaths.exit().transition()
            .duration(1500)
            .attr("opacity", 0)
            .remove();

        //update the path shape
        // console.log(chordPaths)
        chordPaths.transition()
            .duration(1500)
            .style("fill", function(d, i) {
                //get source and target for assists data
                i = d.source.index;
                j = d.target.index;
                t = mmap[i]
                s = mmap[j]
                // console.log(d)
                // console.log(t)
                //total combined assists for a pair
                // combined=assists.filter(function(d) {
                //     return ((d.playerG == s.name && d.playerA ==t.name) || (d.playerG == t.name && d.playerA ==s.name))

                //    })
                // console.log(d.source)
                // console.log(d.target)
                // console.log(d.source.value + d.target.value)
                return color(d.source.value + d.target.value)
            })
            .attrTween("d", chordTween(last_layout))
            .transition().duration(100).attr("opacity", 1) //reset opacity
        ;

        //add the mouseover/fade out behaviour to the groups
        //this is reset on every update, so it will use the latest
        //chordPaths selection
        groupG.on("mouseover", function(d) {
            chordPaths.classed("fade", function(p) {
                //returns true if *neither* the source or target of the chord
                //matches the group that has been moused-over
                return ((p.source.index != d.index) && (p.target.index != d.index));
            });
        });
        //the "unfade" is handled with CSS :hover class on g#circle
        //you could also do it using a mouseout event:
        /*
        g.on("mouseout", function() {
            if (this == g.node() )
                //only respond to mouseout of the entire circle
                //not mouseout events for sub-components
                chordPaths.classed("fade", false);
        });
        */

        last_layout = layout; //save for next update

    }); //end of d3.json
}

function arcTween(oldLayout) {
    //this function will be called once per update cycle

    //Create a key:value version of the old layout's groups array
    //so we can easily find the matching group 
    //even if the group index values don't match the array index
    //(because of sorting)
    var oldGroups = {};
    if (oldLayout) {
        oldLayout.groups().forEach(function(groupData) {
            oldGroups[groupData.index] = groupData;
        });
    }

    return function(d, i) {
        var tween;
        var old = oldGroups[d.index];
        if (old) { //there's a matching old group
            tween = d3.interpolate(old, d);
        } else {
            //create a zero-width arc object
            var emptyArc = {
                startAngle: d.startAngle,
                endAngle: d.startAngle
            };
            tween = d3.interpolate(emptyArc, d);
        }

        return function(t) {
            return arc(tween(t));
        };
    };
}

function chordKey(data) {

    return (data.source.index < data.target.index) ?
        data.source.index + "-" + data.target.index :
        data.target.index + "-" + data.source.index;

    //create a key that will represent the relationship
    //between these two groups *regardless*
    //of which group is called 'source' and which 'target'
}

function chordTween(oldLayout) {
    //this function will be called once per update cycle

    //Create a key:value version of the old layout's chords array
    //so we can easily find the matching chord 
    //(which may not have a matching index)

    var oldChords = {};

    if (oldLayout) {
        oldLayout.chords().forEach(function(chordData) {
            oldChords[chordKey(chordData)] = chordData;
        });
    }

    return function(d, i) {
        //this function will be called for each active chord

        var tween;
        var old = oldChords[chordKey(d)];
        if (old) {
            //old is not undefined, i.e.
            //there is a matching old chord value

            //check whether source and target have been switched:
            if (d.source.index != old.source.index) {
                //swap source and target to match the new data
                old = {
                    source: old.target,
                    target: old.source
                };
            }

            tween = d3.interpolate(old, d);
        } else {
            //create a zero-width chord object
            var emptyChord = {
                source: {
                    startAngle: d.source.startAngle,
                    endAngle: d.source.startAngle
                },
                target: {
                    startAngle: d.target.startAngle,
                    endAngle: d.target.startAngle
                }
            };
            tween = d3.interpolate(emptyChord, d);
        }

        return function(t) {
            //this function calculates the intermediary shapes
            return path(tween(t));
        };
    };
}



$(document).ready(function() {
    $('.teams').on('change', function() {
        team_name = $('.teams').val();
        // document.getElementById("title").innerHTML = $('.teams').val();
        // console.log(team_name)

        // updateChords( "Arizona_matrix.json" );

        d3.csv(team_name + "_players" + year + ".csv", function(error, playerData) {

            if (error) {
                alert("Error reading file: ", error.statusText);
                return;
            }

            players = playerData;
            //store in variable accessible by other functions


            // players = d3.csv.parse(d3.select("#players").text());    //instead of d3.csv
            dataset = team_name + "_matrix" + year + ".json"
            updateChords(dataset);
            // call the update method with the default dataset

        }); //end of d3.csv function


    });

});


</script>


<p>The line thickness represents the number of goals by each player. Thicker lines represent more goals scored. Updates after each game.</p>
<p>Built by <a href="http://mbrownshoes.github.io/#/">Mathew Brown</a><p>
<a href="https://twitter.com/bluebeardata?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @bluebeardata</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
</body>

</html>
